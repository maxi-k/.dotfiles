#!/bin/bash

test -z "$output" && output='column'
test -z "$headers" && headers='on'

if [ -t 0 ]; then
  # running interactively: read from file
  file=${1:-data.csv}
  shift
  sql=${@:-"select * from db limit 5"}
  test -f "$file" || (echo "File $file not found"; exit 1)
else
  # running thru pipe: read from stdin
  sql=${@:-"select * from db limit 5"}
  echo "$sql"
fi

test -z "$sql" && echo "usage: [output=column|csv|line|] $0 [file-if-not-piped] [sqlite-string]" && exit 1

sql_pipe() {
  # remove spaces after line start and commas (padding spaces), then pipe to sqlite
  sed 's/, */,/g' | sed 's/^ *//g' |  sqlite3 :memory: -cmd '.mode csv' -cmd ".import '|cat -' db" -cmd ".mode $output" -cmd ".headers $headers" "$sql"
}

if [ -t 0 ]; then
  cat "$file" | sql_pipe
else
  sql_pipe
fi
